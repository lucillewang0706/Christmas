<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merry Christmas & Happy New Year</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- MediaPipe Hands Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Import Map for React 19, Three.js, and Ecosystem -->
    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.3.1",
                "react/jsx-runtime": "https://esm.sh/react@18.3.1/jsx-runtime",
                "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
                "three": "https://esm.sh/three@0.160.0",
                "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.14?external=react,react-dom,three",
                "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
                "@react-spring/three": "https://esm.sh/@react-spring/three@9.7.3?external=react,react-dom,three,@react-three/fiber",
                "uuid": "https://esm.sh/uuid@9.0.1"
            }
        }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Italianno&family=Cinzel:wght@400;700&display=swap');

        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background-color: #011a0e; }
        #root { width: 100%; height: 100%; }
        
        /* UI Overlay Styles */
        .glass-panel {
            background: rgba(2, 20, 10, 0.4);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(212, 175, 55, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .lux-text {
            font-family: 'Cinzel', serif;
            letter-spacing: 0.15em;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #011a0e; z-index: 50; display: flex; justify-content: center; align-items: center;
            transition: opacity 1s ease-out;
        }
        
        .hidden { opacity: 0; pointer-events: none; }

        /* Camera Preview */
        .input_video {
            transform: scale(-1, 1); /* Mirror */
            width: 160px;
            height: 120px;
            border-radius: 12px;
            opacity: 0.8;
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useMemo, useRef, useEffect, Suspense } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame, useThree } from '@react-three/fiber';
        import { OrbitControls, Text, Environment, Sparkles, Float, PerspectiveCamera, Stars as SkyStars } from '@react-three/drei';
        
        // Dynamic Import Fix for PostProcessing to ensure correct peer deps
        import { EffectComposer as PPComposer, Bloom as PPBloom, Vignette as PPVignette } from "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber";

        import { useSpring, animated, config } from '@react-spring/three';
        import { v4 as uuidv4 } from 'uuid';

        // --- CONSTANTS & CONFIG ---
        const COLORS = {
            emerald: '#0B4628', // Deep Emerald Base
            emeraldHighlight: '#1B7A48', 
            silver: '#E5E4E2',
            gold: '#FFD700',
            paleGold: '#F3E5AB',
            midnight: '#011a0e'
        };

        const FONT_URL = "https://fonts.gstatic.com/s/italianno/v16/gw6ZQdfwpm7h8wyg44yT.woff"; // Elegant cursive

        // --- MATH & GEOMETRY HELPERS ---

        // Generates positions for a cone spiral (The Tree)
        const getTreePos = (i, count, radiusMod = 1, yMod = 1) => {
            const t = i / count;
            const angle = t * Math.PI * 25; // How many turns
            const radius = (5.5 * radiusMod) * (1 - t); // Cone shape: wide bottom, narrow top
            const y = ((t * 14) - 7) * yMod; // Height spread
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            return [x, y, z];
        };

        // Generates random positions (The Galaxy/Scattered state)
        const getScatteredPos = () => {
            const r = 15 + Math.random() * 20;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            return [x, y, z];
        };

        // --- COMPONENTS ---

        // 1. Star Particle (Tree Body & Ornaments)
        const StarParticle = ({ positionTree, rotationTree, color, isTree, scaleVal }) => {
            // Calculate random scatter position once
            const positionScatter = useMemo(() => getScatteredPos(), []);
            // Spin wildly when scattered
            const rotationScatter = useMemo(() => [Math.random() * Math.PI * 4, Math.random() * Math.PI * 4, 0], []);

            const { pos, rot, scale, colorAnim } = useSpring({
                pos: isTree ? positionTree : positionScatter,
                rot: isTree ? rotationTree : rotationScatter,
                scale: isTree ? [scaleVal, scaleVal, scaleVal] : [0.4, 0.4, 0.4],
                colorAnim: isTree ? color : COLORS.silver,
                config: { mass: 2, tension: 150, friction: 40, precision: 0.001 } 
            });

            // A cross shape to mimic a 4-pointed star
            const spikeGeo = useMemo(() => new THREE.ConeGeometry(0.1, 0.8, 4), []);

            return (
                <animated.group position={pos} rotation={rot} scale={scale}>
                    {/* Vertical Spike */}
                    <mesh geometry={spikeGeo}>
                        <animated.meshStandardMaterial 
                            color={colorAnim} 
                            emissive={colorAnim}
                            emissiveIntensity={isTree ? 1.0 : 3}
                            toneMapped={false}
                        />
                    </mesh>
                    {/* Horizontal Spike */}
                    <mesh geometry={spikeGeo} rotation={[0, 0, Math.PI / 2]}>
                        <animated.meshStandardMaterial 
                            color={colorAnim} 
                            emissive={colorAnim}
                            emissiveIntensity={isTree ? 1.0 : 3}
                            toneMapped={false}
                        />
                    </mesh>
                </animated.group>
            );
        };

        // 2. The Crescent Moon (Tree Topper)
        const CrescentMoon = ({ isTree }) => {
            const treePos = [0, 8, 0];
            const scatterPos = [0, 20, -10];

            const { pos, scale, rot } = useSpring({
                pos: isTree ? treePos : scatterPos,
                scale: isTree ? 1 : 3,
                rot: isTree ? [0, 0, Math.PI / 4] : [Math.random(), Math.random(), 0],
                config: config.molasses
            });

            const geometry = useMemo(() => {
                const shape = new THREE.Shape();
                const outerRadius = 1.2;
                const innerRadius = 1.0;
                
                // Outer Circle
                shape.absarc(0, 0, outerRadius, 0, Math.PI * 2, false);
                
                // Subtract Inner Circle (Shifted to make crescent)
                const holePath = new THREE.Path();
                holePath.absarc(-0.4, 0, innerRadius, 0, Math.PI * 2, true);
                shape.holes.push(holePath);

                const extrudeSettings = { depth: 0.3, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 0.05, bevelThickness: 0.05 };
                return new THREE.ExtrudeGeometry(shape, extrudeSettings);
            }, []);

            return (
                <animated.mesh position={pos} scale={scale} rotation={rot} geometry={geometry}>
                    <meshStandardMaterial 
                        color={COLORS.gold}
                        emissive={COLORS.gold}
                        emissiveIntensity={2}
                        toneMapped={false}
                        metalness={1}
                        roughness={0.1}
                    />
                    <pointLight distance={20} decay={2} intensity={5} color={COLORS.gold} />
                </animated.mesh>
            );
        };

        // 3. Floating Letter as Tree Ornament
        const OrnamentText = ({ char, treePos, isTree }) => {
            
            const posScatter = useMemo(() => {
                const p = getScatteredPos();
                return [p[0] * 1.5, p[1] * 1.5, p[2] * 1.5]; 
            }, []);

            const rotScatter = useMemo(() => [Math.random() * Math.PI, Math.random() * Math.PI, 0], []);
            
            // Look at camera roughly when in tree mode
            const rotTree = [0, 0, 0]; 

            const { pos, rot, color } = useSpring({
                pos: isTree ? treePos : posScatter,
                rot: isTree ? rotTree : rotScatter,
                color: isTree ? COLORS.paleGold : COLORS.silver,
                config: config.molasses
            });

            return (
                <animated.group position={pos} rotation={rot}>
                    <Float speed={2} rotationIntensity={0.5} floatIntensity={0.2}>
                        <Text
                            font={FONT_URL}
                            fontSize={0.8}
                            anchorX="center"
                            anchorY="middle"
                        >
                            {char}
                            <animated.meshPhysicalMaterial 
                                color={color}
                                emissive={color}
                                emissiveIntensity={0.6}
                                roughness={0.2}
                                metalness={0.9}
                                toneMapped={false}
                            />
                        </Text>
                    </Float>
                </animated.group>
            );
        };

        // 4. Camera Controller Rig
        const CameraRig = ({ handPosition }) => {
            const { camera } = useThree();
            useFrame((state) => {
                if(handPosition) {
                    const targetX = handPosition.x * 12; 
                    const targetY = handPosition.y * 6;
                    camera.position.x += (targetX - camera.position.x) * 0.05;
                    camera.position.y += (targetY - camera.position.y) * 0.05;
                    camera.lookAt(0, 0, 0);
                }
            });
            return null;
        };

        // 5. Main Scene Manager
        const Scene = ({ isTree, handPosition }) => {
            // A. Generate Tree Particles (Stars)
            const count = 400; 
            const particles = useMemo(() => {
                return new Array(count).fill(0).map((_, i) => {
                    const treePos = getTreePos(i, count);
                    // Add some noise
                    const treeRot = [Math.random() * 0.5, Math.atan2(treePos[0], treePos[2]), Math.random() * 0.5]; 
                    
                    // Logic: 70% Emerald, 15% Silver, 15% Gold
                    const rand = Math.random();
                    let color = COLORS.emerald;
                    let scaleVal = 1;

                    if (rand > 0.85) {
                        color = COLORS.gold; // Gold Star
                        scaleVal = 0.6; // Smaller ornament
                    } else if (rand > 0.70) {
                        color = COLORS.silver; // Silver Star
                        scaleVal = 0.6; // Smaller ornament
                    } else {
                        // Base tree green variations
                         color = Math.random() > 0.5 ? COLORS.emerald : COLORS.emeraldHighlight;
                    }

                    return { id: uuidv4(), treePos, treeRot, color, scaleVal };
                });
            }, []);

            // B. Generate Text Ornaments
            const message = "MERRY CHRISTMAS I LOVE YOU";
            const chars = useMemo(() => {
                const cleanChars = message.replace(/\s/g, '').split('');
                const charCount = cleanChars.length;
                return cleanChars.map((char, i) => {
                    // Distribute text along a wider spiral winding around the tree
                    const t = i / charCount;
                    // Custom spiral for text
                    const angle = t * Math.PI * 8; // 4 full turns
                    const radius = (6.0 * (1 - t)) + 0.5; // Slightly outside the tree
                    const y = (t * 13) - 6; 
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    return { id: `char-${i}`, char, treePos: [x, y, z] };
                });
            }, []);

            return (
                <>
                    <PerspectiveCamera makeDefault position={[0, 0, 24]} fov={45} />
                    
                    {!handPosition && (
                         <OrbitControls 
                            enablePan={false} 
                            autoRotate 
                            autoRotateSpeed={isTree ? 0.8 : 0.2} 
                            maxDistance={35}
                            minDistance={5}
                        />
                    )}
                   
                    <CameraRig handPosition={handPosition} />

                    {/* Lighting: Warm and Magical */}
                    <ambientLight intensity={0.1} color={COLORS.midnight} />
                    <spotLight position={[10, 20, 10]} angle={0.3} penumbra={1} intensity={2} color="#FFF" />
                    <pointLight position={[-10, -5, -10]} intensity={1} color={COLORS.gold} />
                    
                    <Environment preset="night" />

                    {/* The Tree Particles */}
                    <group position={[0, -2, 0]}>
                        {particles.map((p) => (
                            <StarParticle 
                                key={p.id} 
                                positionTree={p.treePos} 
                                rotationTree={p.treeRot} 
                                color={p.color} 
                                isTree={isTree} 
                                scaleVal={p.scaleVal}
                            />
                        ))}
                    </group>

                    {/* Text Ornaments */}
                    <group position={[0, -2, 0]}>
                        {chars.map((c) => (
                             <OrnamentText key={c.id} char={c.char} treePos={c.treePos} isTree={isTree} />
                        ))}
                    </group>

                    <CrescentMoon isTree={isTree} />

                    {/* Atmosphere */}
                    <SkyStars radius={50} depth={50} count={3000} factor={4} saturation={0} fade speed={0.5} />
                    <Sparkles count={150} scale={18} size={4} speed={0.3} opacity={0.5} color={COLORS.gold} />
                    
                    {/* Post Processing */}
                    <PPComposer disableNormalPass>
                        <PPBloom 
                            luminanceThreshold={0.2} 
                            mipmapBlur 
                            intensity={1.0} 
                            radius={0.6}
                        />
                        <PPVignette eskil={false} offset={0.1} darkness={1.2} />
                    </PPComposer>
                </>
            );
        };

        const App = () => {
            const [isTree, setIsTree] = useState(true); 
            const [loaded, setLoaded] = useState(false);
            const [handPosition, setHandPosition] = useState(null); 
            const videoRef = useRef(null);

            useEffect(() => {
                setTimeout(() => setLoaded(true), 1500);

                const onResults = (results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const landmarks = results.multiHandLandmarks[0];
                        const wrist = landmarks[0];
                        const tips = [8, 12, 16, 20]; 
                        let avgDist = 0;
                        
                        tips.forEach(idx => {
                            const dx = landmarks[idx].x - wrist.x;
                            const dy = landmarks[idx].y - wrist.y;
                            avgDist += Math.sqrt(dx*dx + dy*dy);
                        });
                        avgDist /= 4;

                        const isFist = avgDist < 0.25; 
                        setIsTree(isFist);

                        const x = (0.5 - wrist.x) * 4; 
                        const y = (0.5 - wrist.y) * 2; 
                        setHandPosition({x, y});

                    } else {
                        setHandPosition(null);
                    }
                };

                const hands = new window.Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                hands.onResults(onResults);

                if (videoRef.current) {
                    const camera = new window.Camera(videoRef.current, {
                        onFrame: async () => {
                            await hands.send({image: videoRef.current});
                        },
                        width: 640,
                        height: 480
                    });
                    camera.start();
                }

            }, []);

            return (
                <div className="w-full h-full relative bg-[#011a0e]">
                    {/* Loading Screen */}
                    <div className={`loading-overlay ${loaded ? 'hidden' : ''}`}>
                        <div className="text-center">
                            <h1 className="lux-text text-3xl text-[#FFD700] mb-4 animate-pulse">GATHERING STARLIGHT</h1>
                            <div className="w-48 h-1 bg-[#0B4628] rounded mx-auto overflow-hidden">
                                <div className="h-full bg-[#FFD700] animate-[spin_1s_linear_infinite]" style={{width: '50%'}}></div>
                            </div>
                        </div>
                    </div>

                    {/* 3D Canvas */}
                    <Canvas 
                        dpr={[1, 2]} 
                        gl={{ 
                            antialias: false, 
                            toneMapping: THREE.ReinhardToneMapping, 
                            toneMappingExposure: 1.2 
                        }}
                    >
                        <Suspense fallback={null}>
                            <Scene isTree={isTree} handPosition={handPosition} />
                        </Suspense>
                    </Canvas>

                    {/* UI Layer */}
                    <div className="absolute top-0 left-0 w-full h-full pointer-events-none flex flex-col justify-between p-8 z-10">
                        <header className="flex justify-between items-start">
                            <div>
                                <h2 className="lux-text text-xl text-[#FFD700] drop-shadow-lg">MERRY CHRISTMAS <span className="text-white block text-sm mt-1">& HAPPY NEW YEAR</span></h2>
                            </div>
                             {/* Webcam Preview */}
                            <div className="pointer-events-auto">
                                <video ref={videoRef} className="input_video" playsInline muted></video>
                                <p className="text-[10px] text-[#FFD700] text-center mt-1 uppercase tracking-widest">
                                    Gesture Control<br/>
                                    <span className="text-white">Open: Unleash</span> | <span className="text-[#FFD700]">Fist: Tree</span>
                                </p>
                            </div>
                        </header>

                        <footer className="flex justify-center pointer-events-auto pb-8">
                            <button 
                                onClick={() => setIsTree(!isTree)}
                                className="glass-panel px-8 py-4 rounded-full text-[#FFD700] font-sans tracking-[0.2em] text-sm hover:bg-[#FFD700]/10 transition-all duration-500 border border-[#FFD700]/30 group relative overflow-hidden"
                            >
                                <span className="relative z-10">{isTree ? "UNLEASH MAGIC" : "ASSEMBLE TREE"}</span>
                                <div className="absolute inset-0 bg-gradient-to-r from-transparent via-[#FFD700]/20 to-transparent translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700"></div>
                            </button>
                        </footer>
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>